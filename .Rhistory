# Heat index formula from weathermetrics library (based on NOAA algorithm)
"<br>Heat Index: ", heat.index(plotData$temp, rh=plotData$humidity),
"<br>Pace: ", plotData$pace),
hoverinfo = 'text'
)
fig %>% layout(
title = "Actual heat limited pace as calculated on fellrnr's wiki page compared to\na sample of my running data",
scene = list(
xaxis = list(title = "Temperature (F)"),
yaxis = list(title = "Humidity (%)"),
zaxis = list(title = "Pace (min.mi")
))
blogdown:::serve_site()
knitr::opts_chunk$set(echo = F, message = F, warning = F, fig.align = "center")
library(DBI)
library(RSQLite)
con <- dbConnect(SQLite(), "/Users/amrit/HealthData/DBs/garmin_activities.db")
# Get table
runningActs <- dbReadTable(con, 'running_activities_view')
# BKK Summer 2020 running activity IDs
bkkSummer20 <- runningActs$activity_id[2:22]
library(reticulate)
# use_condaenv("r-reticulate")
# py_install("fitparse", pip = TRUE)
# py_install("pytz", pip = TRUE)
# py_module_available("fitparse")
# py_module_available("pytz")
# This file converts Garmin .fit files to .csv files. Ran locally.
py_run_file("/Users/amrit/HealthData/FitFiles/vadhana/convert_fit_to_csv.py", local = T)
library(tidyverse)
library(data.table)
# Assign RHR.
# Based on average over dataset period.
RHR <- 58
# Basic importing, re-formatting and distance correction.
getData <- function(fname) {
run <- tbl_df(read.csv(fname, stringsAsFactors = F))
run <- run %>%
mutate(Laps = row_number(timestamp),
Time.Min = floor(total_elapsed_time / 60),
Time.Sec = total_elapsed_time - Time.Min  * 60,
Distance = total_distance / 1609,
# Distance correction.
Distance = ifelse(Distance < 0.08, 0.072, 2 * 0.072),
Avg.Pace = (Time.Min + Time.Sec / 60) / Distance,
Avg.HR = avg_heart_rate,
Max.HR = max_heart_rate,
RPI = 1 / (((Avg.HR - RHR) * (Time.Min + Time.Sec / 60)) / Distance) * 100000,
Cadence = (avg_running_cadence + avg_fractional_cadence) * 2,
Kcals = total_calories,
Temp = avg_temperature * 9 / 5 + 32,
Date = as.Date(timestamp)
) %>%
select(Laps:Date)
}
setwd("~/HealthData/FitFiles/vadhana")
# lapply + glob passes all .csv files to previously defined data import and formatting function.
data <- lapply(Sys.glob("~/HealthData/FitFiles/vadhana/*.csv"), getData)
# Combine created list data into a single dataframe.
bkkRunningSumm20 <- rbindlist(data) %>% filter(Date != "2020-04-21" | Laps != 51)
library(weathermetrics)
humidity  <-
tribble(
~Date,	~humidity,
"2020-03-24", 54,
"2020-03-25", 61,
"2020-03-27", 57,
"2020-03-30", 57,
"2020-04-07", 68,
"2020-04-10", 54,
"2020-04-14", 68,
"2020-04-16", 67,
"2020-04-19", 57,
"2020-04-21", 51,
"2020-04-24", 57,
"2020-04-27", 70,
"2020-04-30", 71,
"2020-05-05", 70,
"2020-05-07", 55,
"2020-05-10", 58,
"2020-05-15", 54,
"2020-05-20", 56,
"2020-05-24", 65,
"2020-05-26", 67
)
humidity$Date <- as.Date(humidity$Date)
bkkRunningSumm20 <-
left_join(bkkRunningSumm20, humidity) %>%
mutate(heatIndex = heat.index(Temp, rh=humidity))
# Change the data from "wide" to "long'
# to make plotting easier.
pltRunData <-
reshape2::melt(bkkRunningSumm20, id.vars = c("Date", "Laps"))
# Create a dataset of variable means.
meanData <- pltRunData %>%
# Mean data
group_by(Date, variable) %>%
summarise(avg = mean(value)) %>%
# Add a column for mean value
# plot position (y-coordinate)
left_join(pltRunData %>% group_by(variable) %>%
summarise(ypos = 0.95*max(value))) %>%
filter(variable == "Avg.HR" |
variable == "Avg.Pace" |
variable == "Cadence" |
variable == "heatIndex" |
variable == "RPI"
)
lessPlt <- pltRunData %>% filter(variable == "Avg.HR" |
variable == "Avg.Pace" |
variable == "Cadence" |
variable == "heatIndex" |
variable == "RPI"
)
lessMean <- meanData %>% filter(variable == "Avg.HR" |
variable == "Avg.Pace" |
variable == "Cadence" |
variable == "heatIndex" |
variable == "RPI"
)
ggplot(lessPlt, aes(x=Laps, y=value)) +
geom_hline(data=lessMean, aes(yintercept = avg), colour="red", lty=3) +
geom_text(data=lessMean,
aes(label=round(avg,1), x=62, y=ypos),
colour="red",
hjust=1,
size=3) +
xlim(c(1,65)) +
geom_line() +
facet_grid(Date ~ variable, scales = "free")
setwd("~/HealthData/FitFiles/vadhana")
# lapply + glob passes all .csv files to previously defined data import and formatting function.
data <- lapply(Sys.glob("~/HealthData/FitFiles/vadhana/*.csv"), getData)
# Combine created list data into a single dataframe.
bkkRunningSumm20 <- rbindlist(data) %>% filter(Date != "2020-04-21" | Laps != 51)
knitr::opts_chunk$set(echo = F, message = F, warning = F, fig.align = "center")
library(tidyverse)
library(plotly)
library(weathermetrics)
# Heat limited data import and formatting.
hlp <-
tbl_df(read.csv("~/GitHub/myBlog/content/resources/2020-06-13-heat-training/Heat limited pace comparison with BKK summer running data - Temp _ Humidity _ Pace.csv",
stringsAsFactors = F)) %>%
pivot_longer(-T.H, names_to = "humidity", values_to = "pace") %>%
rename(temp = T.H) %>%
mutate(type = "limit")
hlp$humidity <- str_remove(hlp$humidity, "X")
hlp$temp <- as.numeric(hlp$temp)
hlp$humidity <- as.numeric(hlp$humidity)
hlp$pace <- as.numeric(hlp$pace)
# Sample of my running data from runs in BKK during Summer 2020.
data  <-
tribble(
~temp,	~humidity,	~pace, ~type,
91,	67,	8.45, "myData",
90,	65,	8, "myData",
94,	56,	8.583333333, "myData",
95,	54,	9.266666667, "myData",
91,	70,	8.55, "myData",
88,	70,	8.466666667, "myData",
92,	57,	8.533333333, "myData",
97,	51,	8.433333333, "myData"
)
# Combine datasets.
plotData <- bind_rows(hlp, data)
# 3D scatterplot of data.
fig <- plot_ly(type = 'scatter3d',
x = plotData$temp,
y = plotData$humidity,
z = plotData$pace,
color = plotData$type,
text = paste("Make: ", plotData$type,
"<br>Temp: ", plotData$temp,
"<br>Humidity: ", plotData$humidity,
# Heat index formula from weathermetrics library (based on NOAA algorithm)
"<br>Heat Index: ", heat.index(plotData$temp, rh=plotData$humidity),
"<br>Pace: ", plotData$pace),
hoverinfo = 'text'
)
fig %>% layout(
title = "Actual heat limited pace as calculated on fellrnr's wiki page compared to\na sample of my running data",
scene = list(
xaxis = list(title = "Temperature (F)"),
yaxis = list(title = "Humidity (%)"),
zaxis = list(title = "Pace (min.mi")
))
byHI <-
plotData %>% mutate(heatIndex = ifelse(pace != is.na(pace), heat.index(temp, rh=humidity))) %>%
select(type, temp, humidity, heatIndex, pace)
ggplot(byHI, aes(heatIndex, pace, color = type)) +
geom_point() +
theme(legend.position="bottom") +
labs(title =
"Actual heat limited pace as calculated on fellrnr's wiki page compared to\na sample of my running data",
x = "Heat Index (F)",
y = "Pace (min/mi)"
)
library(Hmisc)
ggplot(byHI %>% filter(humidity > 40), aes(temp, pace, color = type)) +
geom_point() +
facet_wrap(~cut2(humidity, c(50, 60, 70, 80, 90, 100))) +
theme(legend.position="bottom") +
labs(title =
"Actual heat limited pace as calculated on fellrnr's wiki page compared to\na sample of my running data",
subtitle = "Groupings by humidity (%)",
x = "Temperature (F)",
y = "Pace (min/mi)"
)
# Fit full model.
heatPaceLOESS <- loess(pace ~ temp + humidity, data = byHI %>% filter(type == "limit"))
library(mgcv)
heatPaceGAM <-
gam(pace ~
# Set the cubic spline as the basis function bs='cr'
# and also not have it penalized with fx=TRUE.
# Both options are set for a smooth term that is set with s().
s(temp, bs = 'cr', k = 4, fx = TRUE) +
s(humidity, bs = 'cr', k = 4, fx = TRUE),
data = byHI %>% filter(type == "limit"))
library(splines)
heatPaceSpline <- lm(pace ~ bs(temp, knots = 7) + bs(humidity, knots = 7), data = byHI %>% filter(type == "limit"))
library(rpart)
heatPacePART <- rpart(pace ~ temp + humidity, data = byHI %>% filter(type == "limit"))
library(DiceKriging)
forKM <-
byHI %>%
filter(type == "limit" & pace != is.na(pace)) %>%
select(temp, humidity, pace)
heatPaceKM <-
km( ~ temp + humidity,
design =
forKM %>% select(temp, humidity),
response =
forKM %>% select(pace)
)
library(lookupTable)
heatPaceLT <-
lookupTable(forKM %>% select(temp, humidity, pace),
'pace',
feature.boundaries =
list(c(-50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100),
c(-50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100)
),
features.con =
c('temp', 'humidity')
)
# Function for returning km response values for mutate calls.
heatLimPace <- function(T, H) {
predict(heatPaceKM, data.frame(temp=c(T), humidity=c(H)), type = "UK")$mean
}
# Add model predictions to dataframe for comparison.
library(modelr)
deltas <-
byHI %>%
add_predictions(heatPaceLOESS, var = "predLOESS") %>%
add_predictions(heatPaceGAM, var = "predGAM") %>%
add_predictions(heatPaceSpline, var = "predSpline") %>%
add_predictions(heatPacePART, var = "predPART") %>%
add_predictions(heatPaceLT, var = "predLT") %>%
# Implementation for kriging model from DiceKriging lib.
mutate(predKM = heatLimPace(temp, humidity)) %>%
mutate(LOESS  = pace - predLOESS,
GAM    = pace - predGAM,
Spline = pace - predSpline,
PART   = pace - predPART,
LT     = pace - predLT,
KM     = pace - predKM
)
plotPreds <-
deltas %>%
filter(type == "limit") %>%
select(temp, humidity, pace:predKM) %>%
rename(actual = pace)
longPreds <-
pivot_longer(plotPreds, actual:predKM, names_to = "type", values_to = "pred")
ggplot(longPreds, aes(temp, pred, color = type)) +
geom_line() +
facet_wrap(~cut2(humidity, c(10, 20, 30, 40, 50, 60, 70, 80, 90, 100)), scales = "free_y") +
theme(legend.position="bottom") +
labs(title = "Actual and predicted heat limited pace from multivariate regression models",
subtitle = "Groupings by humidity (%)",
x = "Temperature (F)",
y = "Pace (min/mi)"
)
library(gghighlight)
ggplot(longPreds, aes(temp, pred, color = type)) +
geom_line() +
facet_wrap(~cut2(humidity, c(10, 20, 30, 40, 50, 60, 70, 80, 90, 100)), scales = "free_y") +
theme(legend.position="bottom") +
gghighlight(type == "actual",
calculate_per_facet = T,
use_direct_label = F
) +
labs(title = "Actual heat limited pace compared to multivariate regression models",
subtitle = "Groupings by humidity (%)",
x = "Temperature (F)",
y = "Pace (min/mi)"
)
ggplot(longPreds, aes(temp, pred, color = type)) +
geom_line() +
facet_wrap(~cut2(humidity, c(10, 20, 30, 40, 50, 60, 70, 80, 90, 100)), scales = "free_y") +
theme(legend.position="bottom") +
gghighlight(type == "actual" | type == "predKM" | type == "predGAM",
calculate_per_facet = T,
use_direct_label = F
) +
labs(title = "Actual and predicted heat limited pace from multivariate regression models",
subtitle = "Groupings by humidity (%)",
x = "Temperature (F)",
y = "Pace (min/mi)"
)
source("~/GitHub/myBlog/content/resources/2020-03-27-100-lap-challenge/100LapChallengePrepare.R")
bkkSummer20 <- getHLP()
plotBKKSumm20 <-
bkkSummer20 %>%
group_by(Date) %>%
summarise(Temp = mean(Temp),
Humidity = mean(humidity),
HeatIndex = mean(heatIndex),
Pace = mean(Avg.Pace),
RPI = mean(RPI)
) %>%
mutate(HeatLimitPace = heatLimPace(Temp, Humidity),
Violation = ifelse(Pace < HeatLimitPace, TRUE, FALSE)
) %>%
select(Date:Pace, HeatLimitPace, Violation, RPI)
ggplot(plotBKKSumm20, aes(Date, RPI, color = Violation)) +
geom_point() +
theme(legend.position="bottom") +
gghighlight(Violation == TRUE,
calculate_per_facet = T,
use_direct_label = F
) +
labs(title = "BKK late Spring 2020 runs at Vadhana fixed track",
subtitle = "Red points indicate when average pace faster than heat limited pace",
x = "Date",
y = "Running Performance Index"
)
library(knitr)
library(kableExtra)
kable(plotBKKSumm20 %>% group_by(Violation) %>% summarise(mean(RPI)),
align = c("l", "c")) %>%
kable_styling(position = "center")
library(knitr)
library(kableExtra)
kable(plotBKKSumm20 %>% group_by(Violation) %>% summarise(avgRPI = mean(RPI)),
align = c("l", "c")) %>%
kable_styling(position = "center")
blogdown:::serve_site()
library(tidyverse)
historical <- tbl_df(read.csv("~/Downloads/Vadhana Running - Historical Full.csv", stringsAsFactors = F))
rpi <-
historical %>%
filter(Activity.Type != "Treadmill Running") %>%
select(Date, Title, Distance, Kcals = Calories, Time, Avg.HR, Cadence = Avg.Run.Cadence, Avg.Pace, Elev.Gain, Elev.Loss, Temp = Min.Temp)
rpi <- rpi[-c(4), ] # Remove erroneous data.
rpi$Date <- as.Date(rpi$Date)
# Cool function allows splitting pace in mm:ss format
# by automatically detecting the ":" separator. This
# is to convert pace to a single plottable number.
rpi <- rpi %>% separate(Avg.Pace, c("Avg.Pace.Min", "Avg.Pace.Sec"))
rpi$Avg.Pace.Min <- as.numeric(rpi$Avg.Pace.Min)
rpi$Avg.Pace.Sec <- as.numeric(rpi$Avg.Pace.Sec)
# Re-format lap time into a single number for plotting.
rpi <- rpi %>% separate(Time, c("Time.Hour", "Time.Min", "Time.Sec"))
rpi$Time.Hour <- as.numeric(rpi$Time.Hour)
rpi$Time.Min <- as.numeric(rpi$Time.Min)
rpi$Time.Sec <- as.numeric(rpi$Time.Sec)
# Total Beats = (Average Heart Rate – Resting Heart Rate) * Time in Minutes
RHR <- 60
# Work Per Mile = Total Beats / Distance in Miles
# Efficiency = 1 / Work Per Mile * 100,000
# Determine RPI (from: https://fellrnr.com/wiki/Running_Economy)
rpi <- rpi %>% mutate(Avg.Pace = Avg.Pace.Min + Avg.Pace.Sec / 60,
Time = Time.Hour * 3600 + Time.Min * 60 + Time.Sec,
RPI = 1 / (((Avg.HR - RHR) * (Time / 60)) / Distance) * 100000)
rpi$Avg.Pace <- as.numeric(rpi$Avg.Pace)
rpi$Elev.Gain <- as.numeric(rpi$Elev.Gain)
rpi$Elev.Gain <- as.numeric(rpi$Elev.Loss)
library(plotly)
p <-
ggplot(rpi, aes(Date, RPI,
label = Title,
label2 = Distance,
label3 = Avg.HR,
label4 = Avg.Pace,
label5 = Temp)) +
geom_point()  +
geom_smooth() # formula = y ~ splines::bs(x, 3)
ggplotly(p)
rpi %>% filter(is.na(RPI)) %>% summarize(n())
rpi %>% filter(is.na(Avg.HR)) %>% summarize(n())
# Stepwise Regression
library(MASS)
fit <- lm(Avg.HR ~ Avg.Pace + Distance, data = rpi)
step <- stepAIC(fit, direction="both")
step$anova # display results
# Stepwise Regression
library(MASS)
fit <- lm(Avg.HR ~ Avg.Pace + Distance, data = rpi)
step <- stepAIC(fit, direction="both")
step$anova # display results
modRPI <-
rpi %>%
mutate(Type = ifelse(is.na(Avg.HR) == TRUE, "Imputed", "Original"),
RPI  = ifelse(is.na(Avg.HR) == TRUE,
step$coefficients[[3]][[1]] * Distance +
step$coefficients[[2]][[1]] * Avg.Pace +
step$coefficients[[1]][[1]],
RPI
)
)
q <-
ggplot(modRPI, aes(Date, RPI, color = Type,
label = Title,
label2 = Distance,
label3 = Avg.HR,
label4 = Avg.Pace,
label5 = Cadence)) +
geom_point()  +
geom_smooth() # formula = y ~ splines::bs(x, 3)
ggplotly(q)
fit <- loess(Avg.HR ~ Avg.Pace + Distance, data = rpi)
modRPI <-
rpi %>%
mutate(Type = ifelse(is.na(Avg.HR) == TRUE, "Imputed", "Original"),
RPI  = ifelse(is.na(Avg.HR) == TRUE,
predict(fit, data.frame(Avg.Pace, Distance)) - 0,
RPI
)
)
r <-
ggplot(modRPI, aes(Date, RPI, color = Type,
label = Title,
label2 = Distance,
label3 = Avg.HR,
label4 = Avg.Pace,
label5 = Cadence)) +
geom_point()  +
geom_smooth(aes(group = 1)) # formula = y ~ splines::bs(x, 3)
ggplotly(r)
modAndShiftRPI <-
rpi %>%
mutate(Type = ifelse(is.na(Avg.HR) == TRUE, "Imputed", "Original"),
RPI  = ifelse(is.na(Avg.HR) == TRUE,
predict(fit, data.frame(Avg.Pace, Distance)) - 35,
RPI
)
)
s <-
ggplot(modAndShiftRPI, aes(Date, RPI, color = Type,
label = Title,
label2 = Distance,
label3 = Avg.HR,
label4 = Avg.Pace,
label5 = Cadence)) +
geom_point()  +
geom_smooth(aes(group = 1)) # formula = y ~ splines::bs(x, 3)
ggplotly(s)
blogdown:::serve_site()
library(tidyverse)
historical <- tbl_df(read.csv("~/GitHub/myBlog/content/resources/2020-03-29-running-economy-over-time/Vadhana Running - Historical Full.csv", stringsAsFactors = F))
rpi <-
historical %>%
filter(Activity.Type != "Treadmill Running") %>%
select(Date, Title, Distance, Kcals = Calories, Time, Avg.HR, Cadence = Avg.Run.Cadence, Avg.Pace, Elev.Gain, Elev.Loss, Temp = Min.Temp)
rpi <- rpi[-c(4), ] # Remove erroneous data.
rpi$Date <- as.Date(rpi$Date)
# Cool function allows splitting pace in mm:ss format
# by automatically detecting the ":" separator. This
# is to convert pace to a single plottable number.
rpi <- rpi %>% separate(Avg.Pace, c("Avg.Pace.Min", "Avg.Pace.Sec"))
rpi$Avg.Pace.Min <- as.numeric(rpi$Avg.Pace.Min)
rpi$Avg.Pace.Sec <- as.numeric(rpi$Avg.Pace.Sec)
# Re-format lap time into a single number for plotting.
rpi <- rpi %>% separate(Time, c("Time.Hour", "Time.Min", "Time.Sec"))
rpi$Time.Hour <- as.numeric(rpi$Time.Hour)
rpi$Time.Min <- as.numeric(rpi$Time.Min)
rpi$Time.Sec <- as.numeric(rpi$Time.Sec)
# Total Beats = (Average Heart Rate – Resting Heart Rate) * Time in Minutes
RHR <- 60
# Work Per Mile = Total Beats / Distance in Miles
# Efficiency = 1 / Work Per Mile * 100,000
# Determine RPI (from: https://fellrnr.com/wiki/Running_Economy)
rpi <- rpi %>% mutate(Avg.Pace = Avg.Pace.Min + Avg.Pace.Sec / 60,
Time = Time.Hour * 3600 + Time.Min * 60 + Time.Sec,
RPI = 1 / (((Avg.HR - RHR) * (Time / 60)) / Distance) * 100000)
rpi$Avg.Pace <- as.numeric(rpi$Avg.Pace)
rpi$Elev.Gain <- as.numeric(rpi$Elev.Gain)
rpi$Elev.Gain <- as.numeric(rpi$Elev.Loss)
historical
rpi
ggplot(rpi, aes(Date, RPI,
label = Title,
label2 = Distance,
label3 = Avg.HR,
label4 = Avg.Pace,
label5 = Cadence)) +
geom_point()  +
geom_smooth()
ggplotly(p)
library(plotly)
p <-
ggplot(rpi, aes(Date, RPI,
label = Title,
label2 = Distance,
label3 = Avg.HR,
label4 = Avg.Pace,
label5 = Cadence)) +
geom_point()  +
geom_smooth() # formula = y ~ splines::bs(x, 3)
ggplotly(p)
